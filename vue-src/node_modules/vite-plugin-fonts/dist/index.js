"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  VitePluginFonts: () => VitePluginFonts,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/google-fonts.ts
var GoogleFontsBase = "https://fonts.googleapis.com/css2";
function injectFonts({
  families,
  text,
  preconnect = true,
  display = "swap",
  injectTo = "head-prepend"
}) {
  const specs = [];
  const deferedSpecs = [];
  const tags = [];
  if (!Array.isArray(families)) {
    console.warn("Google font families is required");
    return tags;
  }
  if (families.length >= 0) {
    for (const family of families) {
      if (typeof family === "string") {
        deferedSpecs.push(family);
        continue;
      }
      if (!family)
        continue;
      const {
        name,
        styles,
        defer = true
      } = family;
      if (!name) {
        console.warn("A google font family name is missing");
        continue;
      }
      let spec = name;
      if (typeof styles === "string")
        spec += `:${styles}`;
      if (defer)
        deferedSpecs.push(spec);
      else
        specs.push(spec);
    }
  }
  if (preconnect && specs.length + deferedSpecs.length > 0) {
    tags.push({
      tag: "link",
      injectTo,
      attrs: {
        rel: "preconnect",
        href: "https://fonts.gstatic.com/",
        crossorigin: true
      }
    });
  }
  if (deferedSpecs.length > 0) {
    let href = `${GoogleFontsBase}?family=${deferedSpecs.join("&family=")}`;
    if (typeof display === "string" && display !== "auto")
      href += `&display=${display}`;
    if (typeof text === "string" && text.length > 0)
      href += `&text=${text}`;
    tags.push({
      tag: "link",
      attrs: {
        rel: "preload",
        as: "style",
        onload: "this.rel='stylesheet'",
        href
      }
    });
  }
  if (specs.length > 0) {
    let href = `${GoogleFontsBase}?family=${specs.join("&family=")}`;
    if (typeof display === "string" && display !== "auto")
      href += `&display=${display}`;
    if (typeof text === "string" && text.length > 0)
      href += `&text=${text}`;
    tags.push({
      tag: "link",
      injectTo,
      attrs: {
        rel: "stylesheet",
        href
      }
    });
  }
  return tags;
}
var google_fonts_default = injectFonts;

// src/typekit.ts
var TypekitFontBase = "https://use.typekit.net/";
function injectFonts2({
  id,
  defer = true,
  injectTo = "head-prepend"
}) {
  const tags = [];
  if (typeof id !== "string") {
    console.warn("A Typekit id is required");
    return tags;
  }
  if (defer) {
    tags.push({
      tag: "link",
      injectTo,
      attrs: {
        rel: "preload",
        as: "style",
        onload: "this.rel='stylesheet'",
        href: `${TypekitFontBase}${id}.css`
      }
    });
  } else {
    tags.push({
      tag: "link",
      injectTo,
      attrs: {
        rel: "stylesheet",
        href: `${TypekitFontBase}${id}.css`
      }
    });
  }
  return tags;
}
var typekit_default = injectFonts2;

// src/custom.ts
var import_fast_glob = require("fast-glob");
var resolveWeight = (weightOrSrc) => {
  if (typeof weightOrSrc === "number")
    return weightOrSrc;
  if (!weightOrSrc)
    return 400;
  weightOrSrc = weightOrSrc.toLowerCase();
  if (weightOrSrc.includes("thin"))
    return 100;
  if (weightOrSrc.includes("extralight"))
    return 200;
  if (weightOrSrc.includes("ultralight"))
    return 200;
  if (weightOrSrc.includes("light"))
    return 300;
  if (weightOrSrc.includes("normal"))
    return 400;
  if (weightOrSrc.includes("medium"))
    return 500;
  if (weightOrSrc.includes("semibold"))
    return 600;
  if (weightOrSrc.includes("demibold"))
    return 600;
  if (weightOrSrc.includes("extrabold"))
    return 800;
  if (weightOrSrc.includes("ultrabold"))
    return 800;
  if (weightOrSrc.includes("bold"))
    return 700;
  if (weightOrSrc.includes("black"))
    return 900;
  if (weightOrSrc.includes("heavy"))
    return 900;
  return 400;
};
var resolveStyle = (styleOrSrc) => {
  if (!styleOrSrc)
    return "normal";
  styleOrSrc = styleOrSrc.toLowerCase();
  if (styleOrSrc.includes("normal"))
    return "normal";
  if (styleOrSrc.includes("italic"))
    return "italic";
  if (styleOrSrc.includes("oblique"))
    return "oblique";
  return "normal";
};
var createFontFaceCSS = ({ name, src, local, weight, style, display }) => {
  const srcs = (Array.isArray(src) ? src : [src]).filter(Boolean).map((url) => {
    let format = url.split(".").pop();
    if (format === "ttf")
      format = "truetype";
    if (format === "otf")
      format = "opentype";
    return `url('${url}') format('${format}')`;
  }).join(",\n		");
  const locals = (Array.isArray(local) ? local : [local]).filter(Boolean).map((x) => `local('${x}')`).join(", ");
  return `@font-face {
  font-family: '${name}';
  src: ${[srcs, locals].filter(Boolean).join(",")};
  font-weight: ${weight};
  font-style: ${style};
  font-display: ${display};
}`;
};
var createFontFaceLink = (prefetch = false, injectTo = "head-prepend") => (href) => {
  return {
    tag: "link",
    injectTo,
    attrs: {
      rel: prefetch ? "prefetch" : "preload",
      as: "font",
      type: `font/${href.split(".").pop()}`,
      href,
      crossorigin: true
    }
  };
};
var custom_default = (options, config2) => {
  const tags = [];
  const css = [];
  let {
    families = [],
    display = "auto",
    preload = true,
    prefetch = false,
    injectTo = "head-prepend"
  } = options;
  if (!Array.isArray(families)) {
    families = Object.entries(families).map(([name, family]) => Array.isArray(family) || typeof family === "string" ? { name, src: family } : { name, ...family });
  }
  for (const { name, src, local } of families) {
    const facesGrouped = {};
    (Array.isArray(src) ? src : [src]).flatMap((x) => (0, import_fast_glob.sync)(x, { absolute: true, cwd: config2.root, onlyFiles: true })).filter(Boolean).forEach((src2) => {
      var _a;
      const srcNoExt = (_a = src2.match(/(.*)\.(\w|\d)+$/)) == null ? void 0 : _a[1].toLowerCase();
      if (srcNoExt)
        facesGrouped[srcNoExt] = (facesGrouped[srcNoExt] ?? []).concat(src2);
    });
    const faces = Object.entries(facesGrouped).map(([srcNoExt, src2]) => ({
      name,
      src: src2,
      weight: resolveWeight(srcNoExt),
      style: resolveStyle(srcNoExt),
      display,
      local
    }));
    const hrefs = faces.flatMap((face) => face.src).map((src2) => src2.replace(config2.root, "."));
    if (preload && prefetch) {
      console.warn("vite-plugin-fonts: Prefetch and a Preload options can not be used together.");
      console.warn("vite-plugin-fonts: The prefetch stand for a lower priority for the resource (maybe we will need it in a future page) whereas preload is for the current page, so we can not have both.");
    }
    if (preload || prefetch)
      tags.push(...hrefs.map(createFontFaceLink(prefetch, injectTo)));
    for (const face of faces)
      css.push(createFontFaceCSS(face));
  }
  return {
    tags,
    css: css.join("\n\n")
  };
};

// src/index.ts
var config;
var MODULE_ID = "virtual:fonts.css";
var MODULE_ID_RESOLVED = "/@vite-plugin-fonts/fonts.css";
function VitePluginFonts(options = {}) {
  return {
    name: "vite-plugin-fonts",
    enforce: "pre",
    configResolved(_config) {
      config = _config;
    },
    transformIndexHtml: {
      enforce: "pre",
      transform: () => {
        const tags = [];
        if (options.typekit)
          tags.push(...typekit_default(options.typekit));
        if (options.google)
          tags.push(...google_fonts_default(options.google));
        if (options.custom)
          tags.push(...custom_default(options.custom, config).tags);
        return tags;
      }
    },
    resolveId(id) {
      if (id === MODULE_ID)
        return MODULE_ID_RESOLVED;
    },
    load(id) {
      if (id === MODULE_ID_RESOLVED)
        return options.custom ? custom_default(options.custom, config).css : "";
    }
  };
}
var src_default = VitePluginFonts;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VitePluginFonts
});
